# Because we need the x and y axis to display every node,
# not just the nodes that have connections to each other,
# make sure that ggplot does not drop unused factor levels
scale_x_discrete(drop = FALSE) +
scale_y_discrete(drop = FALSE) +
theme(
# Rotate the x-axis lables so they are legible
axis.text.x = element_text(angle = 270, hjust = 0),
# Force the plot into a square aspect ratio
aspect.ratio = 1,
# Hide the legend (optional)
legend.position = "none")
# Create the adjacency matrix plot
ggplot(plot_data, aes(x = from, y = to)) +
geom_point(shape=18, size=4, color='steelblue') +
geom_point(data = elec, aes(x=From, y=To), color='grey19')+
theme_bw() +
# Because we need the x and y axis to display every node,
# not just the nodes that have connections to each other,
# make sure that ggplot does not drop unused factor levels
scale_x_discrete(drop = FALSE) +
scale_y_discrete(drop = FALSE) +
theme(
# Rotate the x-axis lables so they are legible
axis.text.x = element_text(angle = 270, hjust = 0),
# Force the plot into a square aspect ratio
aspect.ratio = 1,
# Hide the legend (optional)
legend.position = "none")
wholenet= read.csv("hermPharynx_connections.csv", stringsAsFactors = FALSE)
# Create iGraph object
graph <- graph.data.frame(wholenet, directed = TRUE, vertices = original_nodelist)
# Calculate various network properties, adding them as attributes
# to each node/vertex
V(graph)$comm <- membership(optimal.community(graph))
modularity(graph)
graph
plot(graph)
V(graph)
graph[]
edge_attr(graph)
ceb = cluster_edge_betweenness(graph)
netSimply=as.undirected(graph, mode='collapse',edge.attr.comb=list(weight='sum','ignore'))
ceb = cluster_edge_betweenness(netSimply)
plot(ceb, netSimply)
wholenet= read.csv("herm_connections.csv", stringsAsFactors = FALSE)
wholenet= read.csv("herm_connections.csv", stringsAsFactors = FALSE)
# Create iGraph object
graph <- graph.data.frame(wholenet, directed = TRUE, vertices = original_nodelist)
wholenodelist=read.csv("cell_types.csv", stringsAsFactors = F)
wholenet= read.csv("herm_connections.csv", stringsAsFactors = FALSE)
# Create iGraph object
graph <- graph.data.frame(wholenet, directed = TRUE, vertices = wholenodelist)
netSimply=as.undirected(graph, mode='collapse',edge.attr.comb=list(weight='sum','ignore'))
ceb = cluster_edge_betweenness(netSimply)
plot(ceb, netSimply)
dendPlot(ceb, mode='hclust')
View(ceb)
membership(ceb)
length(ceb)
# Read in CSV files with edge and node attributes
original_edgelist <- read.csv("hermPharynx_connectionsCHEM.csv", stringsAsFactors = FALSE)
original_nodelist <- read.csv("1.2cell_typesPharynx.csv", stringsAsFactors = FALSE)
# Read in CSV files with edge and node attributes
original_edgelist <- read.csv("hermPharynx_connectionsCHEM.csv", stringsAsFactors = FALSE)
original_nodelist <- read.csv("1.2cell_typesPharynx.csv", stringsAsFactors = FALSE)
# Create iGraph object
graph <- graph.data.frame(original_edgelist, directed = TRUE, vertices = original_nodelist)
netSimply=as.undirected(graph, mode='collapse',edge.attr.comb=list(weight='sum','ignore'))
ceb=cluster_edge_betweenness(netSimply)
dendPlot(ceb, mode = 'hclust')
plot(ceb,netSimply)
# Read in CSV files with edge and node attributes
original_edgelist <- read.csv("hermPharynx_connections.csv", stringsAsFactors = FALSE)
original_nodelist <- read.csv("1.2cell_typesPharynx.csv", stringsAsFactors = FALSE)
# Create iGraph object
graph <- graph.data.frame(original_edgelist, directed = TRUE, vertices = original_nodelist)
netSimply=as.undirected(graph, mode='collapse',edge.attr.comb=list(weight='sum','ignore'))
ceb=cluster_edge_betweenness(netSimply)
dendPlot(ceb, mode = 'hclust')
plot(ceb,netSimply)
clp=cluster_label_prop(netSimply)
plot(cpl, netSimply)
plot(clp, netSimply)
cfg=cluster_fast_greedy(netSimply)
plot(cfg, netSimply)
kc=coreness(netSimply,mode='all')
plot(netSimply,vertex.size=kc*6, vertex.label=kc,vertex.color=colrs[kc])
plot(netSimply,vertex.size=kc*6, vertex.label=kc)
V(netSimply)$community=cfg$membership
plot(net, vertex.color=V(netSimply$community))
plot(netSimply, vertex.color=V(netSimply$community))
cfg
View(cfg)
V(netSimply)$community=cfg$membership
colrs <- adjustcolor( c("gray50", "tomato", "gold", "yellowgreen"), alpha=.6)
plot(netSimply, vertex.color=colrs[V(netSimply)$community])
netSimply
plot(cfg, netSimply)
V(netSimply)
V(netSimply)$community
# Re-generate dataframes for both nodes and edges, now containing
# calculated network attributes
node_list <- get.data.frame(graph, what = "vertices")
View(node_list)
# Re-generate dataframes for both nodes and edges, now containing
# calculated network attributes
node_list <- get.data.frame(netSimply, what = "vertices")
View(node_list)
# Create a character vector containing every node name
all_nodes <- sort(node_list$community)
# Adjust the 'to' and 'from' factor levels so they are equal
# to this complete list of node names
plot_data <- edge_list %>% mutate(
to = factor(to, levels = all_nodes),
from = factor(from, levels = all_nodes))
# Create the adjacency matrix plot
ggplot(plot_data, aes(x = from, y = to)) +
geom_point(shape=18, size=4, color='steelblue') +
geom_point(data = elec, aes(x=From, y=To), color='grey19')+
theme_bw() +
# Because we need the x and y axis to display every node,
# not just the nodes that have connections to each other,
# make sure that ggplot does not drop unused factor levels
scale_x_discrete(drop = FALSE) +
scale_y_discrete(drop = FALSE) +
theme(
# Rotate the x-axis lables so they are legible
axis.text.x = element_text(angle = 270, hjust = 0),
# Force the plot into a square aspect ratio
aspect.ratio = 1,
# Hide the legend (optional)
legend.position = "none")
# Adjust the 'to' and 'from' factor levels so they are equal
# to this complete list of node names
plot_data <- edge_list %>% mutate(
to = factor(to, levels = all_nodes),
from = factor(from, levels = all_nodes))
# Create a character vector containing every node name
all_nodes <- sort(node_list$community)
# Create a character vector containing every node name
all_nodes <- sort(node_list$community)
all_nodes
netSimply[order(netSimply$community),]
netSimply
original_nodelist
# Create a character vector containing every node name
all_nodes <- sort(node_list$names)
# Create a character vector containing every node name
all_nodes <- sort(node_list$name)
View(edge_list)
# Re-generate dataframes for both nodes and edges, now containing
# calculated network attributes
node_list <- get.data.frame(netSimply, what = "vertices")
View(node_list)
node_list[order(node_list$community),]
# Create a character vector containing every node name
all_nodes = node_list[order(node_list$community),]
View(all_nodes)
# Create the adjacency matrix plot
ggplot(plot_data, aes(x = from, y = to)) +
geom_point(shape=18, size=4, color='steelblue') +
geom_point(data = elec, aes(x=From, y=To), color='grey19')+
theme_bw() +
# Because we need the x and y axis to display every node,
# not just the nodes that have connections to each other,
# make sure that ggplot does not drop unused factor levels
scale_x_discrete(drop = FALSE) +
scale_y_discrete(drop = FALSE) +
theme(
# Rotate the x-axis lables so they are legible
axis.text.x = element_text(angle = 270, hjust = 0),
# Force the plot into a square aspect ratio
aspect.ratio = 1,
# Hide the legend (optional)
legend.position = "none")
# Adjust the 'to' and 'from' factor levels so they are equal
# to this complete list of node names
plot_data <- edge_list %>% mutate(
to = factor(to, levels = all_nodes),
from = factor(from, levels = all_nodes))
# Create the adjacency matrix plot
ggplot(plot_data, aes(x = from, y = to)) +
geom_point(shape=18, size=4, color='steelblue') +
geom_point(data = elec, aes(x=From, y=To), color='grey19')+
theme_bw() +
# Because we need the x and y axis to display every node,
# not just the nodes that have connections to each other,
# make sure that ggplot does not drop unused factor levels
scale_x_discrete(drop = FALSE) +
scale_y_discrete(drop = FALSE) +
theme(
# Rotate the x-axis lables so they are legible
axis.text.x = element_text(angle = 270, hjust = 0),
# Force the plot into a square aspect ratio
aspect.ratio = 1,
# Hide the legend (optional)
legend.position = "none")
View(plot_data)
all_nodes= sort(node_list$name)
all_nodes_arranged = node_list[order(node_list$community),]
# Create a character vector containing every node name
all_nodes_arranged = node_list[order(node_list$community),]
all_nodes= node_list$name
all_nodes
# Create a character vector containing every node name
all_nodes_arranged = node_list[order(node_list$community),]
View(all_nodes_arranged)
all_nodes_arranged$name
all_nodes= node_nodes_arranged$name
all_nodes= all_nodes_arranged$name
# Adjust the 'to' and 'from' factor levels so they are equal
# to this complete list of node names
plot_data <- edge_list %>% mutate(
to = factor(to, levels = all_nodes),
from = factor(from, levels = all_nodes))
# Create the adjacency matrix plot
ggplot(plot_data, aes(x = from, y = to)) +
geom_point(shape=18, size=4, color='steelblue') +
geom_point(data = elec, aes(x=From, y=To), color='grey19')+
theme_bw() +
# Because we need the x and y axis to display every node,
# not just the nodes that have connections to each other,
# make sure that ggplot does not drop unused factor levels
scale_x_discrete(drop = FALSE) +
scale_y_discrete(drop = FALSE) +
theme(
# Rotate the x-axis lables so they are legible
axis.text.x = element_text(angle = 270, hjust = 0),
# Force the plot into a square aspect ratio
aspect.ratio = 1,
# Hide the legend (optional)
legend.position = "none")
View(plot_data)
#####
V(graph)$degree <- degree(graph)
V(graph)$closeness <- centralization.closeness(graph)$res
V(graph)$betweenness <- centralization.betweenness(graph)$res
V(graph)$eigen <- centralization.evcent(graph)$vector
# Re-generate dataframes for both nodes and edges, now containing
# calculated network attributes
node_list <- get.data.frame(graph, what = "vertices")
View(node_list)
V(graph)$community=cfg$membership
# Re-generate dataframes for both nodes and edges, now containing
# calculated network attributes
node_list <- get.data.frame(graph, what = "vertices")
# Determine a community for each edge. If two nodes belong to the
# same community, label the edge with that community. If not,
# the edge community value is 'NA'
edge_list <- get.data.frame(graph, what = "edges")
View(node_list)
View(node_list)
# Determine a community for each edge. If two nodes belong to the
# same community, label the edge with that community. If not,
# the edge community value is 'NA'
edge_list <- get.data.frame(graph, what = "edges")%>% inner_join(node_list %>% select(name, community), by = c("from" = "name")) %>%
inner_join(node_list %>% select(name, community), by = c("to" = "name")) %>%
mutate(group = ifelse(comm.x == comm.y, comm.x, NA) %>% factor())
# Determine a community for each edge. If two nodes belong to the
# same community, label the edge with that community. If not,
# the edge community value is 'NA'
edge_list <- get.data.frame(graph, what = "edges")%>% inner_join(node_list %>% select(name, community), by = c("from" = "name")) %>%
inner_join(node_list %>% select(name, community), by = c("to" = "name")) %>%
mutate(group = ifelse(community.x == community.y, community.x, NA) %>% factor())
View(edge_list)
# Adjust the 'to' and 'from' factor levels so they are equal
# to this complete list of node names
plot_data <- edge_list %>% mutate(
to = factor(to, levels = all_nodes),
from = factor(from, levels = all_nodes))
# Create the adjacency matrix plot
ggplot(plot_data, aes(x = from, y = to)) +
geom_point(shape=18, size=4, color='steelblue') +
geom_point(data = elec, aes(x=From, y=To), color='grey19')+
theme_bw() +
# Because we need the x and y axis to display every node,
# not just the nodes that have connections to each other,
# make sure that ggplot does not drop unused factor levels
scale_x_discrete(drop = FALSE) +
scale_y_discrete(drop = FALSE) +
theme(
# Rotate the x-axis lables so they are legible
axis.text.x = element_text(angle = 270, hjust = 0),
# Force the plot into a square aspect ratio
aspect.ratio = 1,
# Hide the legend (optional)
legend.position = "none")
# Create the adjacency matrix plot
ggplot(plot_data, aes(x = from, y = to, color=group)) +
geom_point(shape=18, size=4, color='steelblue') +
geom_point(data = elec, aes(x=From, y=To), color='grey19')+
theme_bw() +
# Because we need the x and y axis to display every node,
# not just the nodes that have connections to each other,
# make sure that ggplot does not drop unused factor levels
scale_x_discrete(drop = FALSE) +
scale_y_discrete(drop = FALSE) +
theme(
# Rotate the x-axis lables so they are legible
axis.text.x = element_text(angle = 270, hjust = 0),
# Force the plot into a square aspect ratio
aspect.ratio = 1,
# Hide the legend (optional)
legend.position = "none")
# Create the adjacency matrix plot
ggplot(plot_data, aes(x = from, y = to, color=group)) +
geom_point(shape=18, size=4, color='steelblue') +
geom_point(data = elec, aes(x=From, y=To), color='grey19')+
theme_bw() +
# Because we need the x and y axis to display every node,
# not just the nodes that have connections to each other,
# make sure that ggplot does not drop unused factor levels
scale_x_discrete(drop = FALSE) +
scale_y_discrete(drop = FALSE) +
theme(
# Rotate the x-axis lables so they are legible
axis.text.x = element_text(angle = 270, hjust = 0),
# Force the plot into a square aspect ratio
aspect.ratio = 1,
# Hide the legend (optional)
legend.position = "none")
# Create the adjacency matrix plot
ggplot(plot_data, aes(x = from, y = to, color=group)) +
geom_point(shape=18, size=4) +
geom_point(data = elec, aes(x=From, y=To), color='grey19')+
theme_bw() +
# Because we need the x and y axis to display every node,
# not just the nodes that have connections to each other,
# make sure that ggplot does not drop unused factor levels
scale_x_discrete(drop = FALSE) +
scale_y_discrete(drop = FALSE) +
theme(
# Rotate the x-axis lables so they are legible
axis.text.x = element_text(angle = 270, hjust = 0),
# Force the plot into a square aspect ratio
aspect.ratio = 1,
# Hide the legend (optional)
legend.position = "none")
# First, prepare network attributes with the entire connectome
original_edgelist <- read.csv("hermPharynx_connections.csv", stringsAsFactors = FALSE)
original_nodelist <- read.csv("1.2cell_typesPharynx.csv", stringsAsFactors = FALSE)
# Create iGraph object and calculate network properties
graph <- graph.data.frame(original_edgelist, directed = TRUE, vertices = original_nodelist)
V(graph)$degree <- degree(graph)
V(graph)$closeness <- centralization.closeness(graph)$res
V(graph)$betweenness <- centralization.betweenness(graph)$res
V(graph)$eigen <- centralization.evcent(graph)$vector
ceb=cluster_edge_betweenness(graph)
E(graph)
# Create iGraph object
chemGraph = graph.data.frame(chemConn, directed = TRUE, vertices = V(graph))
# Prepare for plotting
chemConn = read.csv("hermPharynx_connectionsCHEM.csv", stringsAsFactors = FALSE)
# Create iGraph object
chemGraph = graph.data.frame(chemConn, directed = TRUE, vertices = V(graph))
V(graph)
a=V(graph)
a
# Generate dataframe for nodes with updated network attributes
nodes=get.data.frame(graph, what='vertices')
View(nodes)
V(graph)$community=cfg$membership
# Generate dataframe for nodes with updated network attributes
nodes=get.data.frame(graph, what='vertices')
# Prepare plotting with separate graphs for electrical and chemical connections
chemConn = read.csv("hermPharynx_connectionsCHEM.csv", stringsAsFactors = FALSE)
elecConn = read.csv("hermPharynx_connectionsELEC.csv", stringsAsFactors = FALSE)
# Create iGraph object
chemGraph = graph.data.frame(chemConn, directed = TRUE, vertices = nodes)
elecGraph = graph.data.frame(elecConn, directed = T, vertices = nodes)
# Determine a community for each edge. If two nodes belong to the same community, label the edge with that community.
# If not, the edge community value is 'NA'
edgesChem <- get.data.frame(chemGraph, what = "edges")%>%
nc=select(nodes, name, community)
nc=select(nodes, name, community)
View(nc)
View(nodes)
View(edge_list)
# Determine a community for each edge. If two nodes belong to the same community, label the edge with that community.
# If not, the edge community value is 'NA'
edgesChem <- get.data.frame(chemGraph, what = "edges")
View(edgesChem)
edgesChem[from]
edgesChem['from']
nodes
lenth(nodes)
length(nodes)
length(nodes,)
length(nodes[1,])
length(nodes[,1])
nodes['name']
edgesChem
edgesChem[1,1]
length(nodes['name'])
length(nodes[,1])
nodes['name'][1]
nodes['name'][2]
nodes['name'][1,1]
nodes[1]['name']
nodes[1,1]['name']
nodes[,1]['name']
nodes[1,]['name']
colnames(edgesChem)
edgesChem$comm.x=NA
View(edgesChem)
edgesChem$comm.x=NA %>% edgesChem$comm.y=NA %>% edgesChem$group=NA
edgesChem$comm.x=NA
edgesChem$comm.y=NA
edgesChem$group=NA
for (n in length(nodes[,1])){
for (c in length(edgesChem[,1])){
if (edgesChem[c,1]==nodes[n,1]){
edgesChem[c,6]=nodes['community']
}
if (edgesChem[c,2]==nodes[n,1]){
edgesChem[c,7]=nodes['community']
}
}
}
edgesChem[c,7]=nodes[n,7]
View(edgesChem)
for (n in length(nodes[,1])){
if (edgesChem[c,1]==nodes[n,1]){
edgesChem[c,6]=nodes[n,7]
}
if (edgesChem[c,2]==nodes[n,1]){
edgesChem[c,7]=nodes[n,7]
}
}
edgesChem[3,6]
edgesChem[1,1]
edgesChem[2,1]
edgesChem[3,1]
length(nodes[,1])
nodes[1,7]
edgesChem[c,8]=edgesChem[c,6]
edgesChem[c,6]=nodes[n,7]
# Determine a community for each edge. If two nodes belong to the same community, label the edge with that community.
# If not, the edge community value is 'NA'
edgesChem <- get.data.frame(chemGraph, what = "edges")
edgesChem$comm.x=NA
edgesChem$comm.y=NA
edgesChem$group=NA
for (c in length(edgesChem[,1])){
for (n in length(nodes[,1])){
if (edgesChem[c,1]==nodes[n,1]){
edgesChem[c,6]=nodes[n,7]
}
if (edgesChem[c,2]==nodes[n,1]){
edgesChem[c,7]=nodes[n,7]
}
}
}
for (c in length(nodes[,1])){
if (edgesChem[c,7]==edgesChem[c,6]){
edgesChem[c,8]=edgesChem[c,6]
}
}
View(edgesChem)
# Determine a community for each edge. If two nodes belong to the same community, label the edge with that community.
# If not, the edge community value is 'NA'
edgesChem <- get.data.frame(chemGraph, what = "edges") %>%
inner_join(node_list %>% select(name, comm), by = c("from" = "name")) %>%
inner_join(node_list %>% select(name, comm), by = c("to" = "name")) %>%
mutate(group = ifelse(comm.x == comm.y, comm.x, NA) %>% factor())
# Determine a community for each edge. If two nodes belong to the same community, label the edge with that community.
# If not, the edge community value is 'NA'
edgesChem <- get.data.frame(chemGraph, what = "edges") %>%
inner_join(node_list %>% select(name, community), by = c("from" = "name")) %>%
inner_join(node_list %>% select(name, community), by = c("to" = "name")) %>%
mutate(group = ifelse(comm.x == comm.y, comm.x, NA) %>% factor())
# Determine a community for each edge. If two nodes belong to the same community, label the edge with that community.
# If not, the edge community value is 'NA'
edgesChem <- get.data.frame(chemGraph, what = "edges") %>%
inner_join(node_list %>% select(name, community), by = c("from" = "name")) %>%
inner_join(node_list %>% select(name, community), by = c("to" = "name")) %>%
mutate(group = ifelse(community.x == community.y, community.x, NA) %>% factor())
View(edgesChem)
# Determine a community for each edge. If two nodes belong to the same community, label the edge with that community.
# If not, the edge community value is 'NA'
edgesChem = get.data.frame(chemGraph, what = "edges") %>%
inner_join(node_list %>% select(name, community), by = c("from" = "name")) %>%
inner_join(node_list %>% select(name, community), by = c("to" = "name")) %>%
mutate(group = ifelse(community.x == community.y, community.x, NA) %>% factor())
edgesElec = get.data.frame(elecGraph, what = "edges") %>%
inner_join(node_list %>% select(name, community), by = c("from" = "name")) %>%
inner_join(node_list %>% select(name, community), by = c("to" = "name")) %>%
mutate(group = ifelse(community.x == community.y, community.x, NA) %>% factor())
View(edgesElec)
# Adjust the 'to' and 'from' factor levels so they are equal
# to this complete list of node names
plot_data = edgesChem %>% mutate(
to = factor(to, levels = all_nodes),
from = factor(from, levels = all_nodes))
# Create the adjacency matrix plot
ggplot(plot_data, aes(x = from, y = to, color=group)) +
geom_point(shape=18, size=4) +
geom_point(data = edgesElec, aes(x=from, y=to), color='grey19')+
theme_bw() +
# Because we need the x and y axis to display every node,
# not just the nodes that have connections to each other,
# make sure that ggplot does not drop unused factor levels
scale_x_discrete(drop = FALSE) +
scale_y_discrete(drop = FALSE) +
theme(
# Rotate the x-axis lables so they are legible
axis.text.x = element_text(angle = 270, hjust = 0),
# Force the plot into a square aspect ratio
aspect.ratio = 1,
# Hide the legend (optional)
legend.position = "none")
